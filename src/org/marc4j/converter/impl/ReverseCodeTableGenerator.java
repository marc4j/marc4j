package org.marc4j.converter.impl;

import java.io.PrintStream;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.Vector;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;

/**
 * Invoked at build time to generate a java source file (named ReverseCodeTableGenerated.java) 
 * which when compiled will extend the ReverseCodeTable abstract class (primarily through switch 
 * statements) and which can be used be the UnicodeToAnsel converter which will produce the 
 * same results as the object ReverseCodeTableHash.
 * <br>
 * The following routines are only used in the code generation process, and are not available to
 * be called from within an application that uses Marc4j. 
 * <br>
 * The routines generated for converting unicode characters to MARC8 multibyte characters are
 * split into several routines to workaround a limitation in java that a method can only contain 
 * 64k of code when it is compiled. 
 * 
 * @author Robert Haschart
 *  
 */
public class ReverseCodeTableGenerator
{
    public static void main(String[] args) {
        Hashtable<Character,  Hashtable<Integer, char[]>> charsets = null;

        try {

          SAXParserFactory factory = SAXParserFactory.newInstance();
          factory.setNamespaceAware(true);
          factory.setValidating(false);
          SAXParser saxParser = factory.newSAXParser();
          XMLReader rdr = saxParser.getXMLReader();
          
          InputSource src = new InputSource(ReverseCodeTableHandler.class
                                            .getResourceAsStream("resources/codetables.xml"));

          ReverseCodeTableHandler saxUms = new ReverseCodeTableHandler();

          rdr.setContentHandler(saxUms);
          rdr.parse(src);
          charsets = saxUms.getCharSets();
          Vector<Character> combining = saxUms.getCombiningChars();
          Object charsetsKeys[] = charsets.keySet().toArray();
          Arrays.sort(charsetsKeys);
          dumpTablesAsSwitchStatement(combining, charsets, System.out);

        } catch (Exception exc) {
          exc.printStackTrace(System.out);
          System.err.println("Exception: " + exc);
        }
      }
      
      private static void dumpTablesAsSwitchStatement(Vector<Character> combining, Hashtable<Character,  Hashtable<Integer, char[]>> charsets, PrintStream output)
      {
          output.println("package org.marc4j.converter.impl;");
          output.println("");
          output.println("/** ");
          output.println(" *  An implementation of ReverseCodeTable that is used in converting Unicode");
          output.println(" *  data to MARC8 data, that doesn't rely on any data files or resources or data structures");
          output.println(" *  ");
          output.println(" *  Warning: This file is generated by running the main routine in the file ReverseCodeTableHandler.java ");
          output.println(" *  Warning: Do not edit this file, or all edits will be lost at the next build. ");
          output.println(" */" );
          output.println("");
          output.println("import java.util.Hashtable;");
          output.println("");
          output.println("public class ReverseCodeTableGenerated extends ReverseCodeTable {");
          output.println("");
          output.println("\tpublic boolean isCombining(Character c) {");
          output.println("\t\tswitch ((int)c.charValue()) {");
          Character combineArray[] = combining.toArray(new Character[0]);
          Arrays.sort(combineArray);
          Character prevc = null;
          for (int i = 0; i < combineArray.length; i++)
          {
              Character c = combineArray[i];
              if (!c.equals(prevc))
              {
                  output.println("\t\t\tcase 0x"+Integer.toHexString((int)c.charValue()) + ":");
              }
              prevc = c;
          }
          output.println("\t\t\t\treturn true;");
          output.println("\t\t\tdefault: return false;");
          output.println("\t\t}");
          output.println("\t}");
          output.println("");
          output.println("\tpublic Hashtable<Integer, char[]> getCharTable(Character c) {");
          output.println("\t\tString resultStr1 = getCharTableCharSet(c);");
          output.println("\t\tString resultStr2 = getCharTableCharString(c);");
          output.println("\t\tif (resultStr2 == null)  return(null);");
          output.println("\t\tHashtable<Integer, char[]> result = new Hashtable<Integer, char[]>(resultStr1.length());");
          output.println("\t\tString res2[] = resultStr2.split(\" \");");
          output.println("\t\tfor (int i = 0; i < resultStr1.length(); i++) {");
          output.println("\t\t\tresult.put(new Integer(resultStr1.charAt(i)), deHexify(res2[(res2.length==1) ? 0 : i]));");
          output.println("\t\t}");
          output.println("\t\treturn(result);");
          output.println("\t}");
          output.println("");
          Character charsetsKeys[] = charsets.keySet().toArray(new Character[0]);
          Arrays.sort(charsetsKeys);
          StringBuffer buffer = new StringBuffer();
          output.println("\tprivate String getCharTableCharSet(Character c)");
          output.println("\t{");
          output.println("\t\tint cVal = (int)c.charValue();");
          output.println("\t\tswitch(cVal) {");
          for (int sel = 0; sel < charsetsKeys.length; sel++)
          {
              Hashtable<Integer, char[]> table = charsets.get(charsetsKeys[sel]);
              Object tableKeys[] = table.keySet().toArray();
              Arrays.sort(tableKeys);
              StringBuffer sb = new StringBuffer();
              for (int i = 0; i < tableKeys.length; i++)
              {
                  sb.append((char)((Integer)tableKeys[i]).intValue());
              }
              String charset = sb.toString().trim();
              if (!charset.equals("1"))
              {
                  output.println("\t\t\tcase 0x"+Integer.toHexString((int)((Character)charsetsKeys[sel]).charValue())+": return \""+charset+"\";");
              }
          }
          output.println("\t\t}");
          output.println("\t\treturn \"1\";");
          output.println("\t}");
          dumpPartialCharTableCharString(output, buffer, charsetsKeys, charsets, 0, 3500);
          dumpPartialCharTableCharString(output, buffer, charsetsKeys, charsets, 3500, 7000);
          dumpPartialCharTableCharString(output, buffer, charsetsKeys, charsets, 7000, 10500);
          dumpPartialCharTableCharString(output, buffer, charsetsKeys, charsets, 10500, 14000);
          dumpPartialCharTableCharString(output, buffer, charsetsKeys, charsets, 14000, charsetsKeys.length);

          output.println("\tprivate String getCharTableCharString(Character c)");
          output.println("\t{");
          output.println("\t\tint cVal = (int)c.charValue();");
          output.println(buffer.toString());
          output.println("\t\treturn null;");
          output.println("\t}");
          output.println("}");
         
      }
      
      static private void dumpPartialCharTableCharString(PrintStream output, StringBuffer buffer, Object charsetsKeys[], 
                                      Hashtable<Character,  Hashtable<Integer, char[]>> charsets,  int startOffset, int endOffset)
      {
          String startByteStr = "0x"+Integer.toHexString(((int)((Character)charsetsKeys[startOffset]).charValue()));
          String endByteStr = "0x"+Integer.toHexString(((int)((Character)charsetsKeys[endOffset-1]).charValue()));
          buffer.append("\t\tif (cVal >= "+startByteStr+" && cVal <= "+endByteStr+")  return (getCharTableCharString_"+startByteStr+"_"+endByteStr+"(c));\n");
          
          output.println("\tprivate String getCharTableCharString_"+startByteStr+"_"+endByteStr+"(Character c) {");
          output.println("\t\tswitch((int)c.charValue()) {");
          for (int sel = startOffset; sel < charsetsKeys.length && sel < endOffset; sel++)
          {
              Hashtable<Integer, char[]> table = charsets.get(charsetsKeys[sel]);
              Object tableKeys[] = table.keySet().toArray();
              Arrays.sort(tableKeys);
              StringBuffer sb1 = new StringBuffer();
              StringBuffer sb2 = new StringBuffer();
              boolean useSB1 = false;
              char prevcharArray[] = null;
              for (int i = 0; i < tableKeys.length; i++)
              {
                  Object value = table.get(tableKeys[i]);
                  char valarray[] = (char[])value;
                  sb1.append(hexify(valarray));
                  if (i == 0) sb2.append(hexify(valarray));
                  if (i > 0 && valarray.length == 1 && prevcharArray != null &&
                          prevcharArray.length == 1 && valarray[0] != prevcharArray[0])
                  {
                      useSB1 = true;
                  }
                  sb1.append(" ");
                  prevcharArray = valarray;
              }
              String returnVal = useSB1 ? sb1.toString().trim() : sb2.toString().trim();
              output.println("\t\t\tcase 0x"+Integer.toHexString((int)((Character)charsetsKeys[sel]).charValue())+": return \""+returnVal+"\";");
          }
          output.println("\t\t\tdefault: return null;");
          output.println("\t\t}");
          output.println("\t}");  
          output.println("");  
      }
      
      /**
       * Utility function for translating an array of characters to a two character hex string 
       * of the character values
       * 
       * @param valarray - the array of characters to encode
       * @return String - A string representation 
       */
      private static String hexify(char[] valarray)
      {
          String result = "";
          for (int i = 0; i < valarray.length; i++)
          {
              result += Integer.toHexString((int)valarray[i]);
          }
          return result;
      }

}
